<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Dagger2 - 进阶]]></title>
    <url>%2F2018%2F05%2F18%2FDagger2%20-%20%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[Dagger2 - 基础 讲解了Inject，Component，Module，Provides是如何构成Dagger2整个依赖注入框架。本章讲解Qualifier（限定符），Singleton（单例），Scope（作用域），SubComponent，对Dagger2进行细节上的完善。 Qualifier（限定符）]]></content>
      <tags>
        <tag>Dagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger2 - 基础]]></title>
    <url>%2F2018%2F05%2F18%2FDagger2%20-%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Dagger2,它是解决android或java中依赖注入的一个类库（DI类库）。Dagger2能带来哪些好处？Dagger2中的Inject，Component，Module，Provides等等是什么，有什么作用？Dagger2如何使用？ 准备依赖注入： 就是目标类（目标类需要进行依赖初始化的类）中所依赖的其他类的初始化过程，不是通过手动编码的方式创建，而是通过技术手段可以吧其他的类的已经初始化好了的实例自动注入到目标类中。 正式开始Inject先看一段代码123456class A&#123; B b = new B(...); C c = new C(); D d = new D(new E()); F f = new F(.....);&#125; 上面代码在做重复工作，new B() new C()… 我们可以用注解来标注目标类中所依赖的其他类，同样用注解来标注所依赖的其他类的构造函数，那注解的名字就叫Inject12345678910class A&#123; @Inject B b;&#125;class B&#123; @Inject public B()&#123; &#125;&#125; 这样我们就可以让目标类中所依赖的其他类与其他类的构造函数有一种联系。Component就是他们联系的桥梁。 ComponentComponent也是一个注解类，一个类要想是Component，必须用Component注解来标注该类，并且该类是抽象类或接口。Component是目标类所依赖的其他类和其他类的构造函数直接的桥梁，那么Component需要引用到目标类的实例，Component会查找目标类中用Inject注解标注的属性，查找到相应的属性后会接着查找该属性对应的用Inject标注的构造函数（此时就发生了联系），剩下的工作就是初始化该属性的实例并把实例进行赋值。因此我们也可以给Component就另一个名字注入器（Injector）。 小结目标类要想初始化自己所依赖的其他类： 用Inject注解标注目标类的其他类 用Inject注解标注其他类的构造函数（若其他类还依赖于别的类，重复1 2步骤） 调用Component（注入器）的injectXXX（Object）方法开始注入（injectXXX方法名字是官方推荐的名字，以inject开始） Component现在是一个注入器，Component会把目标类依赖的实例注入到目标类中，并初始化目标类的依赖。 为啥又有个Module如果项目中用到第三方的类库，就不能修改第三方类库，所以不可能把Inject注解加入到这些类中，此时Inject就失效了。 那我们怎么封装第三方类库呢，于是Module就派上用场了。可以把封装第三方类库的代码放到Module中：1234567@Modulepublic class ModuleClass&#123; //A是第三方类库中的一个类 A provideA()&#123; return A(); &#125;&#125; Module其实是一个简单工厂模式，Module里面的方法基本都是创建类实例的方法。问题：Component注入器，如何让Component与Module产生联系？ Component新职责Component是注入器，它一端连接目标类，另一端连接目标类的依赖实例，它把目标类实例注入到目标类中。上文中的Module是一个提供类实例的类，所有它是属于Component的实例端的，Component的新职责是管理Module，Component中的modules属性可以把Module加入到Component中，modules可以加入多个Module。 Provides 最终解决第三方类库依赖注入问题Module中创建类实例方法用Provides进行标注，Component在搜索到目标类中用Inject注解标注的属性后，Component就会去Module中查找用Provides标注的对应的创建类实例方法，这样就解决了第三方类库用Dagger2实现依赖注入了。 总结Inject，Component，Module，Provides是Dagger2中最基础最核心的内容。奠定了Dagger2的整个依赖注入框架。 Inject用于标注目标类的依赖，和依赖的构造函数 Component是个桥梁，连接目标类和目标类的依赖的实例，它也是注入器负责把目标类的依赖的实例注入到目标类中，同时管理Module。 Module和Provides是为了解决第三方类库而生的，Module是一个简单工厂模式，Module可以包含创建类实例的方法，这些方法用Provides来标注]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>Dagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计的五个基本原则]]></title>
    <url>%2F2018%2F05%2F16%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BA%94%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[面向对象设计的3个基本要素：封装、继承、多态 面向对象设计的5个基本原则：单一职责原则、开放封闭、里氏置换、依赖倒置、接口隔离 单一职责原则（Single-Resposibility Principle）其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。 开放封闭原则（Open-Closed principle）其核心思想是：软件实体应该是可扩展的，而不是可修改的。也就是说对扩展开放，对修改封闭。1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。实现开开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。“需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。 里氏置换原则（Liskov-Substituion Principle）其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。Liskov替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。Liskov替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。Liskov替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。 依赖倒置原则（Dependecy-Inversion Principle）其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。 接口隔离原则（Interface-Segregation Principle）其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。 总结以上就是5个基本的面向对象设计原则，它们就像面向对象程序设计中的金科玉律，遵守它们可以使我们的代码更加鲜活，易于复用，易于拓展，灵活优雅。不同的设计模式对应不同的需求，而设计原则则代表永恒的灵魂，需要在实践中时时刻刻地遵守。就如ARTHUR J.RIEL在那边《OOD启示录》中所说的：“你并不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。”]]></content>
      <categories>
        <category>设计</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多渠道打包]]></title>
    <url>%2F2018%2F05%2F08%2F%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[1.多渠道打包（gradle）1.替换channel1.在AndroidManifest.xml中添加占位符(友盟统计渠道)123&lt;meta-data android:name=&quot;MTA_CHANNEL&quot; android:value=&quot;$&#123;MTA_CHANNEL_VALUE&#125;&quot; /&gt; 2.在app的build.gradle中添加代码1234567891011android &#123; productFlavors &#123;//需要哪些渠道都写进来 baidu &#123;&#125; _91 &#123;&#125;//不可使用数字开头 wandoujia &#123;&#125; xiaomi &#123;&#125; &#125; //批量处理 productFlavors.all &#123;//替换在AndroidManifest.xml中的$&#123;MTA_CHANNEL_VALUE&#125; flavor -&gt; flavor.manifestPlaceholders = [MTA_CHANNEL_VALUE: name] &#125; 3.打包build -&gt; Generate Signed APK打出来的包位置 2.更改包名当需要更改包名，在productFlavors中指定不同的applicationId即可123456789101112131415161718productFlavors &#123; baidu &#123; applicationId=&quot;com.aimerd.channel.baidu&quot; &#125; _91 &#123; applicationId=&quot;com.aimerd.channel.jiuyi&quot; &#125; wandoujia &#123; applicationId=&quot;com.aimerd.channel.wandoujia&quot; &#125; xiaomi &#123; applicationId=&quot;com.aimerd.channel.xiaomi&quot; &#125;&#125;// 批量处理productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [MTA_CHANNEL_VALUE: name]&#125; 3.生成不同应用名称和图标我们以baidu为例，在app模块src目录下，新建一个”baidu”目录（名字和productFlavors中定义的要一致）目录结构如果需要换图标，只需更换ic_launcher.png文件即可。 把values下strings.xml中的”app_name”改成自己想要的应用名称。123&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;Dragger2_baidu&lt;/string&gt;&lt;/resources&gt; 2.多渠道打包（美团替换文件）引用 美团Android自动化之旅—生成渠道包 https://tech.meituan.com/mt-apk-packaging.html 工具包及使用 https://gitee.com/welau/multichannel_packaging_channel 复制ChannelUtils到项目中12String aDefault = ChannelUtils.getChannel(this);Toast.makeText(this,aDefault,Toast.LENGTH_SHORT).show();//即可获取到channel]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[robolectric-测试]]></title>
    <url>%2F2018%2F05%2F08%2Frobolectric-%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[robolectric的最大特别是运行测试程序时不需要设备或者模拟器，在电脑中进行就可以了，自然测试程序的运行效率可以大大提升。]]></content>
      <categories>
        <category>android 测试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SmartRefreshLayout 刷新加载数据（listview，recycleview，webivew...）]]></title>
    <url>%2F2018%2F04%2F12%2FSmartRefreshLayout-%E5%88%B7%E6%96%B0%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%EF%BC%88listview%EF%BC%8Crecycleview%EF%BC%8Cwebivew-%EF%BC%89%2F</url>
    <content type="text"><![CDATA[引用 SmartRefreshLayout 前言正如名字所说，SmartRefreshLayout是一个“聪明”或者“智能”的下拉刷新布局，由于它的“智能”，它不只是支持所有的View，还支持多层嵌套的视图结构。它继承自ViewGroup 而不是FrameLayout或LinearLayout，提高了性能。 也吸取了现在流行的各种刷新布局的优点，包括谷歌官方的 SwipeRefreshLayout，其他第三方的 Ultra-Pull-To-Refresh、TwinklingRefreshLayout 。还集成了各种炫酷的 Header 和 Footer。 SmartRefreshLayout的目标是打造一个强大，稳定，成熟的下拉刷新框架，并集成各种的炫酷、多样、实用、美观的Header和Footer。 功能特点 支持多点触摸 支持淘宝二楼和二级刷新 支持嵌套多层的视图结构 Layout (LinearLayout,FrameLayout…) 支持所有的 View（AbsListView、RecyclerView、WebView….View） 支持自定义并且已经集成了很多炫酷的 Header 和 Footer. 支持和ListView的无缝同步滚动 和 CoordinatorLayout 的嵌套滚动 . 支持自动刷新、自动上拉加载（自动检测列表惯性滚动到底部，而不用手动上拉）. 支持自定义回弹动画的插值器，实现各种炫酷的动画效果. 支持设置主题来适配任何场景的App，不会出现炫酷但很尴尬的情况. 支持设多种滑动方式：平移、拉伸、背后固定、顶层固定、全屏 支持所有可滚动视图的越界回弹 使用导包12compile &apos;com.scwang.smartrefresh:SmartRefreshLayout:1.1.0-alpha-3&apos;compile &apos;com.scwang.smartrefresh:SmartRefreshHeader:1.1.0-alpha-3&apos;//没有使用特殊Header，可以不加这行 xml123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;com.scwang.smartrefresh.layout.SmartRefreshLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/refreshLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:overScrollMode=&quot;never&quot; android:background=&quot;#fff&quot; /&gt;&lt;/com.scwang.smartrefresh.layout.SmartRefreshLayout&gt; java代码1234567891011121314151617181920212223242526RefreshLayout refreshLayout = (RefreshLayout)findViewById(R.id.refreshLayout);refreshLayout.setOnRefreshListener(new OnRefreshListener() &#123; @Override public void onRefresh(RefreshLayout refreshlayout) &#123; new Handler() &#123; &#125;.postDelayed(new Runnable() &#123; @Override public void run() &#123; refreshLayout.finishRefresh(); &#125; &#125;, 2000); &#125;&#125;);refreshLayout.setOnLoadMoreListener(new OnLoadMoreListener() &#123; @Override public void onLoadMore(RefreshLayout refreshlayout) &#123; new Handler() &#123; &#125;.postDelayed(new Runnable() &#123; @Override public void run() &#123; refreshLayout.finishLoadMore(); //adapter.update(getList()); &#125; &#125;, 2000); &#125;&#125;); 属性设置属性设置1234refreshLayout.setPrimaryColorsId(R.color.colorPrimary, android.R.color.white);//颜色设置refreshLayout.setDragRate(0.5f);//阻尼效果refreshLayout.setHeaderHeight(60);//Header高度dprefreshLayout.setFooterHeight(40);//Footer高度dp Header Footer 设置12345//设置指定的 Header 和 Footer//设置 Header 为 贝塞尔雷达 样式refreshLayout.setRefreshHeader(new ClassicsHeader(this).setTimeFormat(new SimpleDateFormat(&quot;上次更新 HH:mm:ss&quot;)));//设置 Footer 为 球脉冲 样式refreshLayout.setRefreshFooter(new BallPulseFooter(this)); 效果]]></content>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2018%2F03%2F07%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍因程序需要，有时候我们只需要某个类同时保留一个对象，不希望有更多对象，此时，需要用单例模式设计。单例模式特点： 只能有一个实例 单例类必须创建自己唯一的实例 单例类必须向其他对象提供这一实例 单例模式实现方式1. 饿汉模式123456//饿汉模式private static SingletonDemo singletonDemo = new SingletonDemo();private SingletonDemo() &#123;&#125;public static SingletonDemo getInstance()&#123; return singletonDemo;&#125; 在运行这个类的时候进行一次loading，之后直接访问 2. 懒汉模式123456789//懒汉模式private static SingletonDemo singletonDemo;private SingletonDemo() &#123;&#125;public static SingletonDemo getInstance()&#123; if (null == singletonDemo)&#123; singletonDemo = new SingletonDemo(); &#125; return singletonDemo;&#125; 线程不安全 3. 线程安全的懒汉模式12345678private static SingletonDemo singletonDemo;private SingletonDemo() &#123;&#125;public synchronized static SingletonDemo getInstance()&#123; if (null == singletonDemo)&#123; singletonDemo = new SingletonDemo(); &#125; return singletonDemo;&#125; 使用synchronized线程安全了，但并发时这个锁占用了额外的资源，效率低 4. DCL(双重校验锁法)123456789101112private volatile static SingletonDemo singletonDemo; //声明成 volatileprivate SingletonDemo() &#123;&#125;public static SingletonDemo getInstance()&#123; if (null == singletonDemo)&#123;//第一次校验 synchronized (SingletonDemo.class)&#123; if (null == singletonDemo)&#123;//第二次校验 singletonDemo = new SingletonDemo(); &#125; &#125; &#125; return singletonDemo;&#125; 两次判断,这段代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。 给 instance 分配内存 调用 Singleton 的构造函数来初始化成员变量 将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了) 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。我们只需要将 instance 变量声明成 volatile 就可以了。* 5. 静态内部类12345678//静态内部类private SingletonDemo() &#123;&#125;private static class SingletonHolder&#123; private static SingletonDemo singletonDemo = new SingletonDemo();&#125;public static SingletonDemo getInstance()&#123; return SingletonHolder.singletonDemo;&#125; 好处：内部类不会再类加载的时候就加载，而是在调用getInstance()方法时才加载，达到了懒汉模式的效果，而这种方式又是线程安全的 6. 枚举123456789public enum SingletonDemo2 &#123; INSTANCE; public void test()&#123; Log.d(&quot;TAG&quot;,&quot;枚举法单例&quot;); &#125;&#125;//调用方法SingletonDemo2.INSTANCE.test(); 好处：①自由序列化 ②保证只有一个实例 ③线程安全 推荐使用4 5 6这三种方式]]></content>
  </entry>
  <entry>
    <title><![CDATA[EventBus 使用]]></title>
    <url>%2F2018%2F03%2F06%2FEventBus-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[介绍EventBus是一款针对Android优化的发布/订阅事件总线。简化了应用程序内各组件间、组件与后台线程间的通信。优点是开销小，代码更优雅，以及将发送者和接收者解耦。如果Activity和Activity进行交互还好说，如果Fragment和Fragment进行交互着实令人头疼，我们会使用广播来处理，但是使用广播稍显麻烦并且效率也不高，如果传递的数据是实体类需要序列化，那么很显然成本会有点高。今天我们就来学习下EventBus3.0的使用方法。 EventBus的三要素 Event:事件，可以是任意类型的对象 Subscriber:事件订阅者，事件处理的方法可以随便命名，需要价格注解@Subscribe,并且要指定线程模型（默认为POSTING） Publisher：事件发布者，EventBus.getDefault().post() EventBus的5种ThreadMode(线程模型) POSTING(默认)：事件在哪个线程发出，事件就在哪个线程处理 MAIN：事件处理会在UI线程中执行。事件处理时间不能太长（ANR），阻塞式 MAIN_ORDERED:事件处理会在UI线程中执行,非阻塞式 BACKGROUND:事件发出在UI线程时，处理在新线程中运行；事件发出在子线程，处理在该子线程 AYSNC:无论事件在哪个线程发出，处理都会在新建的子线程中运行 EventBus基本用法 导包 1compile &apos;org.greenrobot:eventbus:3.1.1&apos; 自定义一个事件类 123456789101112public class MessageEvent &#123; private String msg; public MessageEvent(String msg) &#123; this.msg = msg; &#125; public String getMsg() &#123; return msg; &#125;&#125; 在需要订阅事件的地方注册事件 1EventBus.getDefault.regist(this); 取消事件订阅 1EventBus.getDefault.unregist(this); 发送事件 1EventBus.getDefault().post(new MessageEvent(&quot;发送事件&quot;)); 处理事件 1234@Subscribe(threadMode = ThreadMode.MAIN_ORDERED)public void XXX(MessageEvent messageEvent) &#123; ...&#125; EventBus 应用 添加依赖 定义消息事件类 注册，取消订阅事件，事件处理事件 （都在MainActivity类中，就写一起了） 12345678910111213141516171819202122232425262728293031public class MainActivity extends AppCompatActivity &#123; private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); EventBus.getDefault().register(this); setContentView(R.layout.activity_main); tv = findViewById(R.id.tv); tv.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this, SecActivity.class)); &#125; &#125;); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this); &#125; @Subscribe(threadMode = ThreadMode.MAIN_ORDERED) public void cal(MessageEvent messageEvent)&#123; tv.setText(messageEvent.getMsg()); Toast.makeText(this,messageEvent.getMsg(),Toast.LENGTH_LONG).show(); &#125;&#125; 事件发布(为了简写：SecActivity 进入就发布) 1234567891011public class SecActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); EventBus.getDefault().post(new MessageEvent(&quot;SecActivity ~&quot;)); &#125;&#125; 看看效果：点击MainActivity的“helloworld” 进入 SecActivity，SecActivity onCreate（）中 post发布事件，MainActivity cal()执行，“helloworld”被改成“SecActivity ~”，同时Toast “SecActivity ~” 粘性事件除了上面讲的普通事件外，EventBus还支持发送黏性事件，就是在发送事件之后再订阅该事件也能收到该事件，跟黏性广播类似。为了验证粘性事件我们修改以前的代码： 订阅粘性事件在MainActivity中我们将注册事件移到到button的点击事件中：1234567bt_subscription.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //注册事件 EventBus.getDefault().register(MainActivity.this); &#125; &#125;); 订阅者处理粘性事件在MainActivity中新写一个方法用来处理粘性事件：1234@Subscribe(threadMode = ThreadMode.POSTING，sticky = true) public void ononMoonStickyEvent(MessageEvent messageEvent)&#123; tv_message.setText(messageEvent.getMessage()); &#125; 发送黏性事件在SecondActivity中发送粘性事件：1EventBus.getDefault().postSticky(new MessageEvent(&quot;粘性事件&quot;)); 混淆12345678910-keepattributes *Annotation*-keepclassmembers class * &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125; # Only required if you use AsyncExecutor-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Retrofit-RxJava-＋-OkHttp基础篇]]></title>
    <url>%2F2018%2F03%2F06%2FRetrofit-RxJava-%EF%BC%8B-OkHttp%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[介绍Retrofit: Retrofit是Square 公司开发的一款正对Android 网络请求的框架。底层基于OkHttp 实现，OkHttp 已经得到了google 官方的认可。Retrofit官网 OkHttp: 也是Square 开源的网络请求库 RxJava:RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。总之就是让异步操作变得非常简单。 各自的职责：Retrofit 负责请求的数据和请求的结果，使用接口的方式呈现，OkHttp 负责请求的过程，RxJava 负责异步，各种线程之间的切换。 RxJava + Retrofit + okHttp 已成为当前Android 网络请求最流行的方式。 Retrofit 写一个网络请求以获取豆瓣 Top250 榜单为例，地址：https://api.douban.com/v2/movie/ 导包 12345678910//rxjava相关依赖compile &apos;io.reactivex:rxjava:1.2.1&apos;compile &apos;io.reactivex:rxandroid:1.2.1&apos;//retrofit相关依赖compile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos;compile &apos;com.squareup.retrofit2:converter-gson:2.1.0&apos;compile &apos;com.squareup.retrofit2:adapter-rxjava:2.1.0&apos;//okhttp相关依赖compile &apos;com.squareup.okhttp3:okhttp:3.4.1&apos;compile &apos;com.squareup.okhttp3:logging-interceptor:3.4.1&apos; 创建一个Retrofit实例，并且完成相关的配置 1234Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .build(); 说明：配置了接口的baseurl和一个converter，GsonConverterFactory是默认的Gson转换器，也支持其他转换器 创建接受结果的javabean1234567891011121314151617public class MovieSubject &#123; public String title; public String start; public String total; public String count; @Override public String toString() &#123; return &quot;MovieSubject&#123;&quot; + &quot;title=&apos;&quot; + title + &apos;\&apos;&apos; + &quot;, start=&apos;&quot; + start + &apos;\&apos;&apos; + &quot;, total=&apos;&quot; + total + &apos;\&apos;&apos; + &quot;, count=&apos;&quot; + count + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 创建一个接口12345678910public interface Service &#123; @GET(&quot;top250&quot;) Call&lt;MovieSubject&gt; getTop250(@Query(&quot;start&quot;) int start,@Query(&quot;count&quot;) int count);&#125;``` *说明：定义一个方法getTop250，使用get请求方式（@GET标签），标签后面是这个接口的尾址top250，完整的地址应该是baseUrl+尾址，参数使用@Query标签，如果参数多的话可以使用@QueryMap标签，接受一个Map*## 用Retrofit创建接口实例MoveService，并且调用接口中的方法进行网络请求 ## //retrofit创建接口实例Service service = retrofit.create(Service.class);//调用getTop250方法Call top250 = service.getTop250(0, 5);//进行网络请求top250.enqueue(new Callback() { @Override public void onResponse(Call call, Response response) { Log.d(“TAG”,”onResponse: “+response.body().toString()); } @Override public void onFailure(Call&lt;MovieSubject&gt; call, Throwable t) { Log.d(&quot;TAG&quot;,&quot;onFailure&quot;); } }); 1234# POST请求 #上面的是GET请求，下面将它换成POST请求 修改MoveService类 public interface Service { @FormUrlEncoded //使用POST必须加上此标签 @POST(&quot;top250&quot;) Call&lt;MovieSubject&gt; getTop250(@Field(&quot;start&quot;) int start, @Field(&quot;count&quot;) int count);//@Query 改成了 @Field }123# 配合RxJava使用 #1. 更改定义的接口，返回值Call-&gt;Observable public interface Service { @GET(&quot;top250&quot;) Observable&lt;MovieSubject&gt; getTop250(@Query(&quot;start&quot;) int start, @Query(&quot;count&quot;) int count); }12. 创建Retrofit时添加代码 addCallAdapterFactory(RxJavaCallAdapterFactory.create())13. Subscriber订阅 //retrofit创建接口实例Service service = retrofit.create(Service.class);service.getTop250(0,5) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber() { @Override public void onCompleted() { Log.d(TAG,”onCompleted”); } @Override public void onError(Throwable e) { Log.d(TAG,&quot;onError: &quot;+e.toString()); } @Override public void onNext(MovieSubject movieSubject) { Log.d(TAG,&quot;onNext: &quot;+movieSubject.title); } }); 12345*以上加入RxJava后的网络请求，返回的不再是Call，而是一个Observable，在Activity或Fragment中传入一个Subscriber建立订阅关系，就可以在onNext中处理结果了。 RxJava的好处是处理线程间的切换*# 加入OkHttp配置 #通过OkHttpClient可以配置很多东西，比如超时，缓存，拦截器 OkHttpClient.Builder builder = new OkHttpClient.Builder() .connectTimeout(60, TimeUnit.SECONDS); //拦截器builder.addInterceptor(new BasicParamsInterceptop());1234## 拦截器(应用拦截器添加公共参数) ##1. 新建类BasicParamsInterceptop implements Interceptor实现intercept方法2. 添加公共参数参数 @Overridepublic Response intercept(Chain chain) throws IOException { Request request = chain.request(); String method = request.method(); Log.d(TAG,”method :”+method); //添加headder request = request.newBuilder() .addHeader(&quot;channel&quot;,&quot;android&quot;).build(); //GET请求 if (method.equals(&quot;GET&quot;)){ HttpUrl httpUrl = request.url().newBuilder() .addQueryParameter(&quot;version&quot;, &quot;version&quot;) .build(); request = request.newBuilder().url(httpUrl).build(); } //POST请求 if(method.equals(&quot;POST&quot;)){ if (request.body() instanceof FormBody){ FormBody.Builder builder = new FormBody.Builder(); //把原来的参数添加到新的构造器 FormBody request_formBody = (FormBody) request.body(); for (int i=0;i&lt;request_formBody.size();i++){ builder.addEncoded(request_formBody.encodedName(i),request_formBody.encodedValue(i)); } //添加新的参数 builder.add(&quot;type&quot;,&quot;app&quot;); request = request.newBuilder().post(builder.build()).build(); } //打印参数 FormBody body = (FormBody) request.body(); for (int i=0;i&lt;body.size();i++){ Log.d(TAG,&quot;new_body :&quot;+body.encodedName(i)); } } return chain.proceed(request); }```]]></content>
  </entry>
  <entry>
    <title><![CDATA[git 使用]]></title>
    <url>%2F2017%2F12%2F21%2Fgit-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[上传本地代码1.新建repository:2.把github上面的仓库克隆到本地git clone https://github.com/xxx/xxx.git（https://github.com/xxx/xxx.git仓库地址）这个步骤以后你的本地项目文件夹下面就会多出个文件夹，该文件夹名即为你github上面的项目名然后把要上传的项目复制到本地项目文件夹中3.git add .4.git commit -m “提交信息”5.git pull origin master6.git push -u origin master 更新代码1.git status(查看当前的git仓库状态)2.git add *(更新全部)3.git commit -m “更新说明”4.git pull(先git pull,拉取当前分支最新代码)5.git push origin master(push到远程master分支上) 参考上传本地代码及更新代码到GitHub教程]]></content>
  </entry>
  <entry>
    <title><![CDATA[RxJava + Retrofit 完成网络请求]]></title>
    <url>%2F2017%2F11%2F29%2FRxJava-Retrofit-%E5%AE%8C%E6%88%90%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[RxJava使用介绍一个在Java VM上使用可观测的序列来组成异步的,基于事件的程序的库.简单说它就是一个实现异步操作的库. 观察者模式 观察者: 监视被观察者的行为,当被观察组某个状态改变的时候会通知观察者,观察组执行对应的操作; 被观察者: 被监视的对象 订阅(或注册): 将观察者和被观察者建立联系 例子: 按钮点击事件(OnClickListener中的onClick()事件) 观察者: OnClickListener; 被观察者: Button; 订阅(或注册): setOnClickListener(); 对应RxJava中 观察者: Observer; 被观察者: Observable; 订阅(或注册): subscribe; 观察者Observer 即观察者,它决定事件触发的时候将有怎样的行为.RxJava 观察者的事件回调方法除了普通事件onNext()[相当于onClick()/onEvent()]之外,还定义了两个特殊的事件:onCompleted()和onError(). onCompleted() 事件队列完结.RxJava不仅把每个事件单独处理,还会把它们看成一个队列.RxJava规定,当不会再有新的onNext()发出时,需要触发onCompleted()方法作为标示. onError() 事件队列异常.在事件处理过程中出现异常时,onError()会被触发,同时队列自动终止,不允许再有事件发出. 在一个正确运行的事件序列中,onCompleted()和onError()有且只有一个,并且是事件序列中的最后一个.onCompleted()和onError()在队列中只会调用其中一个. 被观察者Observable 即被观察者,它决定什么时候触发事件以及触发怎样的事件.可以使用create(),just(T…),from(T[]),from(Iterable&lt;? extends T&gt;)来创建一个Observable,并为它定义事件触发规则. 订阅创建了Observable 和 Observer之后,再用subscribe()方法将他们连接起来 使用1.导包12compile &apos;io.reactivex:rxjava:1.0.14&apos;compile &apos;io.reactivex:rxandroid:1.0.1 2.创建一个观察者1234567891011121314Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.i(TAG, &quot;Completed&quot;); &#125; @Override public void onError(Throwable e) &#123; Log.i(TAG, &quot;Error&quot;); &#125; @Override public void onNext(String s) &#123; Log.i(TAG, s); &#125;&#125;; 3.创建被观察者12345678Observable observable1 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(&quot;Hello&quot;); subscriber.onNext(&quot;Wrold&quot;); subscriber.onCompleted(); &#125;&#125;); 4.订阅1observable1.subscribe(observer); 5.Observable其它几种创建方法 Observable.just() 1Observable observable = Observable.just(&quot;hi&quot;, &quot;le&quot;, &quot;ho&quot;); Observable.from() 12345List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(&quot;Hellow&quot;);list.add(&quot;Wrold&quot;);String [] words = &#123;&quot;Hello&quot;, &quot;World&quot;&#125;;Observable observable3 = Observable.from(words|list); RxJava Action 使用回顾上节知识,介绍RxJava基本用法例:分别打印”hello” “world”123456789101112Observable.just(&quot;hello&quot;,&quot;world&quot;) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; &#125; &#125;); 从上面可以看出我们只用了onNext(obj),还有两个重新的onError()和onCompleted()并没有用到,可是使用Action代替Subscriber. Action代替Subscriber用Action代替Subscriber1234567Observable.just(&quot;Hello&quot;, &quot;World&quot;) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, s); &#125; &#125;); RxJava 转换 -map -flatMapmap在使用map之前先了解一个接口: Func1, Func1和上文的Action1相似.Func1和Action1的区别在于,Func1包装的是有返回值的方法.例: 得到多个Studeng对象中的name,保存到nameList中123456789101112131415Observable.just(student1, student2, student2) //使用map进行转换，参数1：转换前的类型，参数2：转换后的类型 .map(new Func1&lt;Student, String&gt;() &#123; @Override public String call(Student i) &#123; String name = i.getName();//获取Student对象中的name return name;//返回name &#125; &#125;) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; nameList.add(s); &#125; &#125;); 可以看出Observable中原来的参数是Student对象,而最后我们需要的是name,这里使用了map来实现这一转换的过程.map也可以多次使用 flatMapflatMap是一个比教难理解的一个转换，在这里先假设一个需求，需要打印多个Student所学的课程。这跟之前获取Student的name又不同了，这里先确定一下关系，一个Student类中只有一个name，而一个Student却有多门课程（Course），Student我们可以理解成这样：12345678910111213141516/*** 学生类*/class Student &#123; private String name;//姓名 private List&lt;Course&gt; coursesList;//所修的课程 ...&#125;/*** 课程类*/class Course &#123; private String name;//课程名 private String id; ...&#125; 如何使用map实现打印所有学生所修的课程名12345678910111213Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123; @Override public Observable&lt;Course&gt; call(Student student) &#123; return Observable.from(student.getCoursesList()); &#125; &#125;) .subscribe(new Action1&lt;Course&gt;() &#123; @Override public void call(Course course) &#123; Log.i(TAG, course.getName()); &#125;&#125;); RxJava 线程控制 - Scheduler由Observable发起事件,经过中间的处理后由Observer消费,之前的代码事件发起和消费都是在同一个线程中执行,也就是说之前我们使用的RxJava是同步的而观察者模式本身的目的是后台处理,将处理结果回调给前台上例中flatMap处理是在主线程中进行的,若flatMap中有耗时的操作,这样会导致主线程阻塞 Scheduler: 线程控制器,可以指定每一段代码在什么样的线程中执行例: 在新的线程中发起事件,在主线程中消费123456789Observable.just(&quot;Hello&quot;, &quot;Word&quot;) .subscribeOn(Schedulers.newThread())//指定 subscribe() 发生在新的线程 .observeOn(AndroidSchedulers.mainThread())// 指定 Subscriber 的回调发生在主线程 .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, s); &#125; &#125;); 上面用到了subscribeOn()发起,observeOn()消费subscribeOn()：指定subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程.observeOn()：指定Subscriber 所运行在的线程。或者叫做事件消费的线程。 多次切换线程1234567891011121314151617Observable.just(&quot;hello&quot;,&quot;hi&quot;) .subscribeOn(Schedulers.newThread()) .observeOn(Schedulers.io()) .filter(new Func1&lt;String, Boolean&gt;() &#123; @Override public Boolean call(String s) &#123; Log.d(TAG,&quot;filter thread: &quot;+Thread.currentThread().getId()); return true; &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d(TAG,&quot;Thread: &quot;+Thread.currentThread().getId()+&quot; &quot;+s); &#125; &#125;); 可以看出subserveOn()被调用两次,分别指定fliter处理和subscribe消费的线程如果去掉后面的.observeOn(AndroidSchedulers.mainThread()),那么 .subscribe将会在io线程中执行observeOn()可以多次使用，可以随意变换线程 Retrofit 使用Retrofit是Square公司开发的一个类型安全的Java和Android的REST客户端库(A type-safe HTTP client for Android and Java)RestAPI是一种软件设计风格,服务器作为资源存放地.客户端去请求GET POST PUT DELETE…资源.并且是无状态的,没有session的参与. Retrofit模型如下: 1.POJO或模型实体类: 从服务器获取的JSON数据将被填充到这种类的实例中2.接口: 我们需要创建一个接口来管理像GET POST…请求的URL,这是一个服务类.3.RestAdapter类: 这是一个REST客户端(RestClient)类,retrofit中默认用的是Gson来解析JSON数据,你也可以设置自己的JSON解析器. 原理在发起请求时,主要通过Call来封装每一次的请求;调用同步方法时,会使用应用线程来发送请求;调用异步方法时,会通过 OkHttp 的 Dispatcher 提供的线程来执行请求. Dispatcher: r内部实现了懒加载无边界限制的线程池方式，同时该线程池采用了SynchronousQueue这种阻塞队列。SynchronousQueue每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。显然这是一种快速传递元素的方式，也就是说在这种情况下元素总是以最快的方式从插入者（生产者）传递给移除者（消费者），这在多任务队列中是最快处理任务的方式。 Retrofit 使用准备工作:1.添加依赖12compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos;compile &apos;com.squareup.retrofit2:converter-gson:2.0.2&apos; 2.添加权限由于是网络请求,需要添加访问网络权限1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 步骤1.创建实体类12345678910111213141516171819public class User &#123; private String name; private String age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = ge &#125;&#125; 创建一个User类, name agePOJO的转换推荐使用GsonFormat 2.创建Retrofit对象12345Retrofit retrofit = new Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create())//解析方法 //这里建议：- Base URL: 总是以/结尾；- @Url: 不要以/开头 .baseUrl(&quot;http://www.xxx.com/&quot;) .build(); 3.接口申明12345678910public interface Service &#123; /** * 根据id获取对应的用户数据 * 如果不需要转换成Json数据,可以用了ResponseBody; * @param id * @return call */ @GET(&quot;user/&#123;id&#125;&quot;) Call&lt;User&gt; getUser(@Path(&quot;id&quot;) String id);&#125; 4.创建访问API的请求12Service api = retrofit.create(Service .class);Call&lt;User&gt; call = api.getUser(&quot;123456&quot;); 5.调用5.1 同步调用1News news = call.execute(); 5.2 异步调用1234567891011call.enqueue(new Callback&lt;News&gt;()&#123; @Override public void onResponse(Response&lt;News&gt; response) &#123; //成功返回数据后在这里处理，使用response.body();获取得到的结果 News news = response.body(); &#125; @Override public voidonFailure(Throwable t) &#123; //请求失败在这里处理 &#125; &#125;); 6.取消请求1call.cancel(); RxJava + Retrofit 结合使用单独使用Retrofit1.service接口1234567interface MyService &#123; @GET(&quot;user/login&quot; ) Call&lt;UserInfo&gt; login( @Query(&quot;username&quot;) String username, @Query(&quot;password&quot;) String password );&#125; 2.获取Call执行网络请求123456789101112131415161718Retrofit retrofit = new Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create()) .baseUrl(BASE_URL) .build();MyService service = retrofit.create(MyService.class);Call&lt;UserInfo&gt; call = service.login(&quot;1111&quot;, &quot;ssss&quot;);call.enqueue(new Callback&lt;UserInfo&gt;() &#123; @Override public void onResponse(Call&lt;UserInfo&gt; call, Response&lt;UserInfo&gt; response) &#123; //请求成功操作 &#125; @Override public void onFailure(Call&lt;UserInfo&gt; call, Throwable t) &#123; //请求失败操作 &#125;&#125;); RxJava + Retrofit 完成网络请求1.添加依赖 前四个分别是RxJava、RxAndroid、Retrofit以及Gson的库，最后那个才是新加入的，RxJava + Retrofit的使用需要用到最后那个包。12345compile &apos;io.reactivex:rxjava:x.y.z&apos;compile &apos;io.reactivex:rxandroid:1.0.1&apos;compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos;compile &apos;com.squareup.retrofit2:converter-gson:2.0.2&apos;compile &apos;com.squareup.retrofit2:adapter-rxjava:2.0.2&apos; 注意: 最后三个包的版本号必须一样2.修改service(Call改为Observable)1234567interface MyService &#123; @GET(&quot;user/login&quot; ) Observable&lt;UserInfo&gt; login( @Query(&quot;username&quot;) String username, @Query(&quot;password&quot;) String password );&#125; 3.网络请求12345678910111213141516171819202122232425262728Retrofit retrofit = new Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create()) .baseUrl(BASE_URL) .build();MyService service = retrofit.create(MyService.class);service.loging(username,password) .subscribeOn(Schedulers.newThread())//请求在新的线程中执行 .observeOn(Schedulers.io()) //请求完成后在io线程中执行 .doOnNext(new Action1&lt;UserInfo&gt;() &#123; @Override public void call(UserInfo userInfo) &#123; saveUserInfo(userInfo);//保存用户信息到本地 &#125; &#125;) .observeOn(AndroidSchedulers.mainThread())//最后在主线程中执行 .subscribe(new Subscriber&lt;UserInfo&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(UserInfo userInfo) &#123; &#125; &#125;); Retrofit把请求封装进Observable,在请求结束后调用onNext() onError() 或 onCompleted().在调用service的login方法后得到Observable对象, .subscribeOn(Scheduler.newThread())在新的线程中执行网络请求,请求成功后切换到io线程执行保存用户信息动作,最后再切换到主线程执行请求失败,成功动作.整体逻辑都在一条链中,即使有变更也好添加修改.逻辑清晰. 引用【Android】RxJava + Retrofit完成网络请求]]></content>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView]]></title>
    <url>%2F2017%2F11%2F09%2FRecyclerView%2F</url>
    <content type="text"><![CDATA[前言谷歌在support v7中,加入了新的控件-RecyclerView用来代替ListView GridView,结合了ListView GridView的特点,并实现了瀑布流效果. 导包需要v7 包支持1implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; 几个重要的类 RecyclerView.Adapter:抽象类，为RecyclerView提供数据，一般根据不同的业务需求来编写具体的实现类。 RecyclerView.LayoutManager:抽象类，主要用于测量RecyclerView的子Item，以及根据不同的布局方式来实现Item的布局效果，v 7包自带的实现类有：LinearLayoutManager、StaggeredGridLayoutManager、GridLayoutManager… RecyclerView.ItemDecoration:抽象类，这个主要用于不同的Item之间添加分割线（可选）。官方没有实现类，所以如果要添加分割线，我们需要手动实现这个抽象类 RecyclerView.ItemAnimator:抽象类，这个主要用于当一个item添加或者删除的时候出现的动画效果，官方提供一个默认的实现类。如果想要使我们的RecyclerView在添加、删除数据的时候有炫酷的动画，可以实现这个抽象类 xml布局123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.v7.widget.Toolbar android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:titleTextColor=&quot;@color/white&quot; app:title=&quot;RecyclerView&quot;/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recyclerview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 这里使用了4个控件, CoordinatorLayout, AppBarLayout, Toolbar和本文的RecyclerView item_recyclerview.xml123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_item&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;70dp&quot; android:background=&quot;#ccc&quot; /&gt;&lt;/RelativeLayout&gt; item布局只有一个TextView, 背景颜色灰色 java代码(初试)1234RecyclerView recyclerview = findViewById(R.id.recyclerview);recyclerview.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false));MyAdapter myAdapter = new MyAdapter(data);recyclerview.setAdapter(myAdapter); 代码解析:recyclerview.setLayoutManager:设置布局管理器 LinearLayoutManager 以垂直或水平列表方式展示 GridLayoutManager 以网格方式展示 StaggeredGridLayoutManager 以瀑布流方式展示 recyclerview.setAdapter:设置适配器,适配器代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243private class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt;&#123; private ArrayList&lt;String&gt; mData; public MyAdapter(ArrayList&lt;String&gt; data) &#123; this.mData = data; &#125; public void updateData(ArrayList&lt;String&gt; data) &#123;//用户数据更新 this.mData = data; notifyDataSetChanged(); &#125; @Override public MyAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; //实例化展示的View, View inflate = View.inflate(RecyclerViewActivity.this, R.layout.item_recyclerview, null); //实例化ViewHolder ViewHolder viewHolder = new ViewHolder(inflate); return viewHolder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; //holder就是onCreateViewHolder返回, 绑定数据 holder.textView.setText(mData.get(position)); &#125; @Override public int getItemCount() &#123; return mData.size(); &#125; public class ViewHolder extends RecyclerView.ViewHolder&#123; TextView textView; public ViewHolder(View itemView) &#123; super(itemView); textView = itemView.findViewById(R.id.tv_item); &#125; &#125; &#125; 效果图:效果和ListView一样,但是item直接没有分割线,xml文件中也不能设置分割线,可以通过mRecyclerView.addItemDecoration()来设置我们定义好的间隔样式. 添加分割线LinearLayoutManager 分割线12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class DividerItemDecoration extends RecyclerView.ItemDecoration&#123; private static final int[] ATTRS = new int[]&#123; android.R.attr.listDivider &#125;; public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL; public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL; private Drawable mDivider; private int mOrientation; public DividerItemDecoration(Context context, int orientation) &#123; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); setOrientation(orientation); &#125; public void setOrientation(int orientation) &#123; if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) &#123; throw new IllegalArgumentException(&quot;invalid orientation&quot;); &#125; mOrientation = orientation; &#125; @Override public void onDraw(Canvas c, RecyclerView parent) &#123; if (mOrientation == VERTICAL_LIST) &#123; drawVertical(c, parent); &#125; else &#123; drawHorizontal(c, parent); &#125; &#125; public void drawVertical(Canvas c, RecyclerView parent) &#123; final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); android.support.v7.widget.RecyclerView v = new android.support.v7.widget.RecyclerView(parent.getContext()); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; public void drawHorizontal(Canvas c, RecyclerView parent) &#123; final int top = parent.getPaddingTop(); final int bottom = parent.getHeight() - parent.getPaddingBottom(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123; if (mOrientation == VERTICAL_LIST) &#123; outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); &#125; else &#123; outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); &#125; &#125;&#125; 12recyclerview.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false));recyclerview.addItemDecoration(new com.newyulong.materialdesignstu.DividerItemDecoration.DividerItemDecoration(this, com.newyulong.materialdesignstu.DividerItemDecoration.DividerItemDecoration.VERTICAL_LIST)); 效果图: GridLayoutManager分割线123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175public class DividerGridItemDecoration extends RecyclerView.ItemDecoration &#123; private static final int[] ATTRS = new int[] &#123; android.R.attr.listDivider &#125;; private Drawable mDivider; private int divider_height = 2; public DividerGridItemDecoration(Context context) &#123; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); &#125; public DividerGridItemDecoration(Context context,int px_divider_height) &#123; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); mDivider.setColorFilter(Color.WHITE,PorterDuff.Mode.SRC); divider_height = px_divider_height; a.recycle(); &#125; public DividerGridItemDecoration(Context context,int px_divider_height,int divider_color) &#123; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); mDivider.setColorFilter(divider_color,PorterDuff.Mode.SRC); divider_height = px_divider_height; a.recycle(); &#125; @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; drawHorizontal(c, parent); drawVertical(c, parent); &#125; private int getSpanCount(RecyclerView parent) &#123; // 列数 int spanCount = -1; RecyclerView.LayoutManager layoutManager = parent.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; spanCount = ((GridLayoutManager) layoutManager).getSpanCount(); &#125; else if (layoutManager instanceof StaggeredGridLayoutManager) &#123; spanCount = ((StaggeredGridLayoutManager) layoutManager) .getSpanCount(); &#125; return spanCount; &#125; public void drawHorizontal(Canvas c, RecyclerView parent) &#123; int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getLeft() - params.leftMargin; final int right = child.getRight() + params.rightMargin + divider_height; final int top = child.getBottom() + params.bottomMargin; final int bottom = top + divider_height; mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; public void drawVertical(Canvas c, RecyclerView parent) &#123; final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getTop() - params.topMargin; final int bottom = child.getBottom() + params.bottomMargin; final int left = child.getRight() + params.rightMargin; final int right = left + divider_height; mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; private boolean isLastColum(RecyclerView parent, int pos, int spanCount, int childCount) &#123; RecyclerView.LayoutManager layoutManager = parent.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边 &#123; return true; &#125; &#125; else if (layoutManager instanceof StaggeredGridLayoutManager) &#123; int orientation = ((StaggeredGridLayoutManager) layoutManager) .getOrientation(); if (orientation == StaggeredGridLayoutManager.VERTICAL) &#123; if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边 &#123; return true; &#125; &#125; else &#123; childCount = childCount - childCount % spanCount; if (pos &gt;= childCount)// 如果是最后一列，则不需要绘制右边 return true; &#125; &#125; return false; &#125; private boolean isLastRaw(RecyclerView parent, int pos, int spanCount, int childCount) &#123; RecyclerView.LayoutManager layoutManager = parent.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; childCount = childCount - childCount % spanCount; if (pos &gt;= childCount)// 如果是最后一行，则不需要绘制底部 return true; &#125; else if (layoutManager instanceof StaggeredGridLayoutManager) &#123; int orientation = ((StaggeredGridLayoutManager) layoutManager) .getOrientation(); // StaggeredGridLayoutManager 且纵向滚动 if (orientation == StaggeredGridLayoutManager.VERTICAL) &#123; childCount = childCount - childCount % spanCount; // 如果是最后一行，则不需要绘制底部 if (pos &gt;= childCount) return true; &#125; else // StaggeredGridLayoutManager 且横向滚动 &#123; // 如果是最后一行，则不需要绘制底部 if ((pos + 1) % spanCount == 0) &#123; return true; &#125; &#125; &#125; return false; &#125; @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123; int spanCount = getSpanCount(parent); int childCount = parent.getAdapter().getItemCount(); if (isLastRaw(parent, itemPosition, spanCount, childCount))// 如果是最后一行，则不需要绘制底部 &#123; outRect.set(0, 0, divider_height, 0); &#125; else if (isLastColum(parent, itemPosition, spanCount, childCount))// 如果是最后一列，则不需要绘制右边 &#123; outRect.set(0, 0, 0, divider_height); &#125; else &#123; outRect.set(0, 0, divider_height,divider_height); &#125; &#125;&#125; 123recyclerview.addItemDecoration(new com.newyulong.materialdesignstu.DividerItemDecoration.DividerItemDecoration(this, com.newyulong.materialdesignstu.DividerItemDecoration.DividerItemDecoration.VERTICAL_LIST));//recyclerview.setLayoutManager(new GridLayoutManager(this,4,LinearLayoutManager.HORIZONTAL,false));//横向GridViewrecyclerview.addItemDecoration(new DividerGridItemDecoration(this)); 效果图: 瀑布流StaggeredGridLayoutManager:瀑布流布局管理器1recyclerview.setLayoutManager(new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL)); 效果图:居然和GridLayoutManager的效果一样!修改第二项item的高度为80,其他的为160 item点击事件在MyAdapter中定义如下接口,模拟ListView的OnItemClickListener：123public static interface OnItemClickListener &#123; void onItemClick(View view , int position); &#125; 在onCreateViewHolder()中为每个item添加点击事件12345678@Override public ViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) &#123; View view = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.item, viewGroup, false); ViewHolder vh = new ViewHolder(view); //将创建的View注册点击事件 view.setOnClickListener(this); return vh; &#125; 将点击事件转移给外面的调用者：1234567@Override public void onClick(View v) &#123; if (mOnItemClickListener != null) &#123; //注意这里使用getTag方法获取position mOnItemClickListener.onItemClick(v,(int)v.getTag()); &#125; &#125; 注意上面调用接口的onItemClick()中的v.getTag()方法，这需要在onBindViewHolder()方法中设置和item的position123456@Override public void onBindViewHolder(ViewHolder viewHolder, int position) &#123; viewHolder.mTextView.setText(datas[position]); //将position保存在itemView的Tag中，以便点击时进行获取 viewHolder.itemView.setTag(position); &#125; 最后暴露给外面的调用者，定义一个设置Listener的方法（）：1234private OnItemClickListener mOnItemClickListener = null;public void setOnItemClickListener(OnItemClickListener listener) &#123; this.mOnItemClickListener = listener; &#125; 总结本文讲的是RecycView布局,列表形式,网格形式,瀑布流形式.使用RecycView需要设置布局管理器(LinearLayoutManager,GridLayoutManager,StaggeredGridLayoutManager)同样需要适配器(继承RecyclerView.Adapter), 需要重写onCreateViewHolder方法(实例化ViewHolder), onBindViewHolder方法(得到ViewHolder,绑定数据), 以及getItemCount方法,还需要定义ViewHolder类继承RecyclerView.ViewHolder类设置分割线设置动画(删除,增加item时的动画)]]></content>
  </entry>
  <entry>
    <title><![CDATA[CollapsingToolbarLayout]]></title>
    <url>%2F2017%2F11%2F08%2FCollapsingToolbarLayout%2F</url>
    <content type="text"><![CDATA[简介CollapsingToolbarLayoutCollapsingToolbarLayout作用是提供一个可以折叠的Toolbar,给它设置layout_scrollFlags,就可以控制其内的控件(如:ImageView,Toolbar)在响应layout_behavior事件时做出相应的scrollFlags滚动事件. xml布局文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;300dp&quot; app:contentScrim=&quot;@color/colorPrimary&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; app:title=&quot;Toolbar&quot;&gt; &lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@mipmap/coll&quot; app:layout_collapseMode=&quot;parallax&quot; app:layout_collapseParallaxMultiplier=&quot;0.5&quot; /&gt; &lt;android.support.v7.widget.Toolbar android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:layout_collapseMode=&quot;pin&quot; app:navigationIcon=&quot;@mipmap/back_black_arra&quot; /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;@string/txt_appbar&quot; /&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; CollapsingToolbarLayout包含一个ImageView和一个Toolbar,把这个CollapsingToolbarLayout放到AppBarLayout中作为一个整体。 在CollapsingToolbarLayout中: 我们必须设置layout_scrollFlags ImageView中: layout_collapseMode(折叠模式): pin: 当CollapsingToolbarLayout完全收缩后,Toolbar还可以保留在屏幕上. parallax: 在内容滚动时，CollapsingToolbarLayout中的View（比如ImageView)也可以同时滚动，实现视差滚动效果，通常和layout_collapseParallaxMultiplier(设置视差因子)搭配使用 layout_collapseParallaxMultiplier: 设置视差滚动因子，值为：0~1 Toolbar中: layout_collapseMode(折叠模式)：为pin(Toolbar保留在屏幕上) 上例分析: 当向上滚动时,ImageView会有视觉差的向上滚出屏幕,最后Toolbar会固定在最顶端效果图: 样式修改修改Toolbar title颜色12ctl.setExpandedTitleColor(getResources().getColor(R.color.white));ctl.setCollapsedTitleTextColor(getResources().getColor(R.color.white)); 修改折叠后Toolbar背景颜色 (app:contentScrim)上例xml文件中已经将Toolbar背景颜色修改过,1234567&lt;android.support.design.widget.CollapsingToolbarLayout android:id=&quot;@+id/ctl&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;300dp&quot; app:contentScrim=&quot;@color/colorPrimary&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; app:title=&quot;Toolbar&quot;&gt; 不然会显示ImageView内容,去掉看看 总结CollapsingToolbarLayout是Toolbar的扩充,提供折叠功能.使用时,用它包含Toolbar和其他内容(如ImageView)达到炫酷的效果.]]></content>
      <tags>
        <tag>material design组件学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppBarLayout]]></title>
    <url>%2F2017%2F11%2F08%2FAppBarLayout%2F</url>
    <content type="text"><![CDATA[官方文档介绍AppBarLayout是一个垂直的LinearLayout，实现了Material Design中app bar的scrolling gestures特性。AppBarLayout的子View应该声明想要具有的“滚动行为”，这可以通过layout_scrollFlags属性或是setScrollFlags()方法来指定。AppBarLayout只有作为CoordinatorLayout的直接子View时才能正常工作，为了让AppBarLayout能够知道何时滚动其子View，我们还应该在CoordinatorLayout布局中提供一个可滚动View，我们称之为scrolling view。scrolling view和AppBarLayout之间的关联，通过将scrolling view的Behavior设为AppBarLayout.ScrollingViewBehavior来建立。根据上文我们知道,AppBarLayout主要功能是当位于同一父容器中的可滚动View发生滚动式,APPBarLayout会根据scolling view声明的滚动行为来对其子View进行相应的滚动.先来看张图:AppBarLayout包含Toolbar和一个TextView(没有设置scrollFlags)当向上滚动式,ToolBar会消失;向下滚动时,ToolBar会出现.AppBarLayout就是这么神奇 xml布局文件上面例子的xml布局文件:123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/abl&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.v7.widget.Toolbar android:layout_width=&quot;match_parent&quot; app:title=&quot;Toolbar&quot; app:layout_scrollFlags=&quot;scroll&quot; android:layout_height=&quot;?attr/actionBarSize&quot;&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;15dp&quot; android:text=&quot;toolbar 下方的textview&quot;/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; &gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;@string/txt_appbar&quot; android:lineSpacingMultiplier=&quot;1.5&quot;/&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 布局文件中,NestedScrollView是scrolling view,scrolling view需要支持嵌套滚动. 上面的Toolbar的layout_scrollFlags属性被设置为了”scroll”,Toolbar就会随着scrolling view的滚动而滚动,下面解释下scrollFlags: scroll 设置成这个值就好比Toolbar和scrolling view是一体的. exitUntilCollapsed 当Toolbar向上滚出屏幕时,会被折叠直到达到最小高度停止折叠 下图为了演示,将Toolbar的高度设置成200dp,注释掉Toolbar下方的TextView enterAlways 只要向下滚动时,先滚动Toolbar,完全展开后才会去滚动scrolling view enterAlwaysCollapsed 在enterAlways基础上加了折叠效果.当我们开始向下滚动scrolling view是,Toolbar会跟着滚动知道达到其”折叠高度”(即最小高度).然后当scrolling view滚动到完全显示后,再向下滚动scrolling view,Toolbar会接着滚动到完全显示出来 注意,要达到上图效果,需要把layout_scrollFlags指定为”scroll|enterAlways|enterAlwaysCollapsed”. snap 在一次滚动结束时，Toolbar很可能只处于“部分显示”的状态，加上这个标记能够达到“要么完全隐藏，要么完全显示”的效果。 总结 AppBarLayout是一个垂直的LinearLayout AppBarLayout需要和CoordinatorLayout一起使用,并作为它的直接子View 为了实现滚动还应在Coordinator布局中提供一个可滚动View(scrolling view),scrolling view还需设置app:layout_behavior=”@string/appbar_scrolling_view_behavior”建立联系 设置AppBarLayout子View的scrollFlag属性,控制其可以根据scrolling view的滚到而滚动]]></content>
      <tags>
        <tag>material design组件学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoordinatorLayout]]></title>
    <url>%2F2017%2F11%2F08%2FCoordinatorLayout%2F</url>
    <content type="text"><![CDATA[CoordinatorLayout并不局限于与AppbarLayout,CollapsingToolbarLayout,Toolbar配合使用,它的功能强大着呢.CoordinatorLayout:behaivor协调view,它是帮助协调各个子View的布局.其中Behavior就是一个应用于View的观察者模式,一个View跟随着另一个View的变化而变化,或者说一个View监听另一个View.在Behavior中,被观察View也就是事件源被称为denpendcy,而观察View,则被称为clild. clild跟随denpendcy CoordinatorLayout使用xml1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/btn&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;btn&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;100dp&quot; android:text=&quot;跟随btn&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; Activity123456789101112131415161718192021public class CoordinatorLayoutActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_coordinatorlayout); Button btn = findViewById(R.id.btn); btn.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_MOVE: v.setX(event.getRawX()-v.getWidth()/2); v.setY(event.getRawY()-v.getHeight()/2); break; &#125; return false; &#125; &#125;); &#125;&#125; 按钮可以跟随手指移动 自定义类集成Behavior类创建一MyBehavior类,集成Behavior123456789101112131415161718public class MyBehavior extends CoordinatorLayout.Behavior&lt;TextView&gt; &#123; public MyBehavior(Context context, AttributeSet attrs) &#123;//必不可少 super(context, attrs); &#125; @Override public boolean layoutDependsOn(CoordinatorLayout parent, TextView child, View dependency) &#123; return dependency instanceof Button; &#125; @Override public boolean onDependentViewChanged(CoordinatorLayout parent, TextView child, View dependency) &#123; child.setX(dependency.getX());//此处的denpendency就是btn1 child.setY(dependency.getY()+200); return true; &#125;&#125; 注意:layoutDependsOn() 代表寻找被观察View,本例是ButtononDependentViewChanged() 被观察View变化的时候回调用的方法,本例是TextView.其中dependency就是Button,于是我们让TextView跟随Button的移动而移动必须重写带双参的构造器，因为从xml反射需要调用。然后，在xml中，给TextView设置我们的Behavior。123456&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;100dp&quot; android:text=&quot;跟随btn&quot; app:layout_behavior=&quot;.behavior.MyBehavior&quot; /&gt; 效果图: 总结本文讲解CoordinatorLayout的使用,一个Child(TextView) 跟随 dependency移动,定义一个继承Behavior的类,Child(TextView)增加app:layout_behavior属性指向这个类,那么就可实现跟随动作]]></content>
      <tags>
        <tag>material design组件学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TabLayout]]></title>
    <url>%2F2017%2F11%2F07%2FTabLayout%2F</url>
    <content type="text"><![CDATA[TabLayout是Android Support Design Library库中的一个控件,提供了一个水平的布局用来展示Tabs。 导包使用Snackbar要导入com.android.support:design库。1compile &apos;com.android.support:design:26.1.0&apos; 一般使用 xml文件 12345678&lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tabLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#eee&quot; app:tabSelectedTextColor=&quot;#666&quot; app:tabTextColor=&quot;#ccc&quot;&gt;&lt;/android.support.design.widget.TabLayout&gt; java代码 1234TabLayout tabLayout = findViewById(R.id.tabLayout);tabLayout.addTab(tabLayout.newTab().setText(&quot;tab1&quot;));tabLayout.addTab(tabLayout.newTab().setText(&quot;tab2&quot;));tabLayout.addTab(tabLayout.newTab().setText(&quot;tab3&quot;)); 效果图 样式修改 设置未选择时字体颜色 1app:tabTextColor=&quot;#0f0&quot; 设置选中时的字体颜色 1app:tabSelectedTextColor=&quot;@color/colorAccent&quot; 设置指示器颜色 1app:tabIndicatorColor=&quot;#f00&quot; 设置Tab背景颜色 1app:tabBackground=&quot;@color/blue&quot; 看看效果: 设置TabItem字体大小 1app:tabTextAppearance=&quot;@android:style/TextAppearance.Large&quot; 设置指示器下标高度 1app:tabIndicatorHeight=&quot;5dp&quot; Tab模式 1app:tabMode=&quot;scrollable&quot; //默认为fixed 添加图标 1tabLayout.addTab(tabLayout.newTab().setText(&quot;icon&quot;).setIcon(R.mipmap.ic_launcher)); 多添加几个tag,看看效果: Tab宽度限制设置最小宽度:app:tabMinWidth=”100dp”可以看出每个Tab的宽度变宽了 TabLayout的监听事件1234567891011121314tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; public void onTabSelected(TabLayout.Tab tab) &#123; //tab被选中 Log.d(TAG,&quot;onTabSelected: &quot;+tab.getPosition()); &#125; public void onTabUnselected(TabLayout.Tab tab) &#123; //tab取消选中 Log.d(TAG,&quot;onTabUnselected: &quot;+tab.getPosition()); &#125; public void onTabReselected(TabLayout.Tab tab) &#123; //tab再次被选中 Log.d(TAG,&quot;onTabReselected: &quot;+tab.getPosition()); &#125;&#125;); 切换Tab,看看日志:0 -&gt; 1: 0unSelected 1selected1 -&gt; 3: 1unSelected 3selected3 -&gt; 0: 3unSelected 0selected TabLayout与ViewPager联动 配置viewpage的adapter,实现getPageTitle(position)方法 使用setupWithViewPager(viewpager)关联代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class TabLayoutActivity extends AppCompatActivity &#123; private final static String TAG = &quot;TabLayoutActivity&quot;; private String[] mTitleArray = &#123;&quot;item1&quot;, &quot;xitem2&quot;, &quot;xxxitem3&quot;, &quot;xxxxitem4&quot;,&quot;xxxxxitem5&quot;&#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_tablayout); TabLayout tabLayout = findViewById(R.id.tabLayout); ViewPager vp = findViewById(R.id.vp); vp.setAdapter(new MyAdapter());// 去掉addTab(),从viewpage 的 getPageTitle()中获取// tabLayout.addTab(tabLayout.newTab().setText(&quot;icon&quot;).setIcon(R.mipmap.ic_launcher));// tabLayout.addTab(tabLayout.newTab().setText(&quot;tab1&quot;));// tabLayout.addTab(tabLayout.newTab().setText(&quot;tab2&quot;));// tabLayout.addTab(tabLayout.newTab().setText(&quot;tab3&quot;));// tabLayout.addTab(tabLayout.newTab().setText(&quot;tab4&quot;));// tabLayout.addTab(tabLayout.newTab().setText(&quot;tab5&quot;));// tabLayout.addTab(tabLayout.newTab().setText(&quot;tab6&quot;)); tabLayout.setupWithViewPager(vp);//关联viewpager tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; public void onTabSelected(TabLayout.Tab tab) &#123; //tab被选中 Log.d(TAG,&quot;onTabSelected: &quot;+tab.getPosition()); &#125; public void onTabUnselected(TabLayout.Tab tab) &#123; //tab取消选中 Log.d(TAG,&quot;onTabUnselected: &quot;+tab.getPosition()); &#125; public void onTabReselected(TabLayout.Tab tab) &#123; //tab再次被选中 Log.d(TAG,&quot;onTabReselected: &quot;+tab.getPosition()); &#125; &#125;); &#125; private class MyAdapter extends PagerAdapter &#123; public int getCount() &#123; return mTitleArray.length; &#125; public boolean isViewFromObject(View view, Object object) &#123; return view == object; &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; TextView tv = new TextView(TabLayoutActivity.this); tv.setText(mTitleArray[position]); tv.setGravity(Gravity.CENTER); container.addView(tv, ViewPager.LayoutParams.MATCH_PARENT, ViewPager.LayoutParams.WRAP_CONTENT); return tv; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView((View) object); &#125; @Override public CharSequence getPageTitle(int position) &#123; return mTitleArray[position];//title给TabLayout使用 &#125; &#125;&#125; 效果图: 扩展(设置下划线宽度和文字一样长)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public void reflex(final TabLayout tabLayout, final int margin, final int padding) &#123; //了解源码得知 线的宽度是根据 tabView的宽度来设置的 tabLayout.post(new Runnable() &#123; @Override public void run() &#123; try &#123; //拿到tabLayout的mTabStrip属性 LinearLayout mTabStrip = (LinearLayout) tabLayout.getChildAt(0); //计算总长度 float sumWith = 0; for (int i = 0; i &lt; mTabStrip.getChildCount(); i++) &#123; View tabView = mTabStrip.getChildAt(i); //拿到tabView的mTextView属性 tab的字数不固定一定用反射取mTextView Field mTextViewField = tabView.getClass().getDeclaredField(&quot;mTextView&quot;); mTextViewField.setAccessible(true); TextView mTextView = (TextView) mTextViewField.get(tabView); tabView.setPadding(0, 0, 0, 0); //因为我想要的效果是 字多宽线就多宽，所以测量mTextView的宽度 int width = 0; width = mTextView.getWidth(); if (width == 0) &#123; mTextView.measure(0, 0); width = mTextView.getMeasuredWidth(); &#125; //设置tab左右间距为10dp 注意这里不能使用Padding 因为源码中线的宽度是根据 tabView的宽度来设置的 LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) tabView.getLayoutParams(); params.width = width + 2 * padding; params.leftMargin = margin; params.rightMargin = margin; tabView.setLayoutParams(params); tabView.invalidate(); sumWith += 2 * margin + 2 * padding + width; &#125; int sc_with = getWindowManager().getDefaultDisplay().getWidth(); if (sumWith &lt;= sc_with) &#123;//总长度小于屏幕宽度时MODE_FIXED,否则MODE_SCROLLABLE tabLayout.setTabMode(TabLayout.MODE_FIXED); &#125; else &#123; tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE); &#125; &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);&#125; 下划线和文字一样长,并且可以设置所tabitem的数量动态调整TabMode(MODE_FIXED|MODE_SCROLLABLE),可以设置margin和padding. 总结本文讲解了TabLayout的常规使用:背景颜色,选中未选中颜色,指示器高度颜色…属性介绍TabLayout大多和ViewPager配合使用:使用setupWithViewPager(viewpager)关联ViewPager,适配器还要实现getPagerTitle(position)方法返回title供TabLayout tabItem使用]]></content>
      <tags>
        <tag>material design组件学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FloatingActionButton]]></title>
    <url>%2F2017%2F11%2F07%2FFloatingActionButton%2F</url>
    <content type="text"><![CDATA[FloatingActionButton是Android Support Design Library库中的一个控件,类似一个圆形图片按钮 导包使用FloatingActionButton要导入com.android.support:design库。1compile &apos;com.android.support:design:26.1.0&apos; xml布局文件12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:fabSize=&quot;auto&quot; app:elevation=&quot;1dp&quot; android:src=&quot;@mipmap/add&quot; android:clickable=&quot;true&quot; app:backgroundTint=&quot;#33ce33&quot; app:rippleColor=&quot;#0000ff&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 使用简单,当做ImageBubbon使用,设置src 白色的”+”号. FloatingActionButton常用属性 app:fabSize:为了符合Material Design的设计风格，Google给出了FloatingActionButton的三种大小值：mini、normal、auto. app:elevation=”6dp”：为了有投影悬浮效果，为FloatingActionButton设置一个高度值.高度值越大，投影效果越淡，投影范围越大.高度值越小，投影效果越浓，投影范围越小. app:rippleColor：为了符合Material Design的设计风格，为了使可点击的选项给用户反馈，点击时会有水波纹扩散的效果.默认值是灰色的水波纹效果。如果设置rippleColor没有效果，记得设置属性android:clickable=”true”. app:pressedTranslationZ=”10dp”：设置阴影的点击效果。与elevation控制的同一地方的阴影，不过elevation是非按压时的阴影效果，而pressedTranslationZ是点击按钮时阴影的效果. app:backgroundTint： 改变FloatingActionButton的背景颜色. android:src: 设置FloatingActionButton的背景内容当然也可以在java代码中设置这些参数 总结FloatingActionButton使用简单,和ImageBotton类似,多一些ripple,投影效果]]></content>
      <tags>
        <tag>material design组件学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Snackbar]]></title>
    <url>%2F2017%2F11%2F07%2FSnackbar%2F</url>
    <content type="text"><![CDATA[Snackbar是Android Support Design Library库中的一个控件，可以在屏幕底部快速弹出消息，比Toast更加好用。 导包使用Snackbar要导入com.android.support:design库。1compile &apos;com.android.support:design:26.1.0&apos; 一般使用Snackbar基本使用和Toast类似123456789Snackbar.make(view,&quot;hello world&quot;,Snackbar.LENGTH_INDEFINITE) .setAction(&quot;你好&quot;, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //点击后关闭Snackbar Toast.makeText(SnackbarActivity.this,&quot;Snackbar被点击了&quot;,Toast.LENGTH_LONG).show(); &#125; &#125;) .show(); 属性解析:make()生成Snackbar.第一个参数是容纳view,推荐使用CoordinatorLayout来确保Snackbar和其他组件的交互,比如向右右滑动Snackbar可取消,Snackbar出现时FloatingActionButton上移.第二个参数是提示内容.第三个参数是显示时间:LENGTH_SHORT、LENGTH_LONG和LENGTH_INDEFINITE。setAction()设置右侧按钮,可增加点击事件.如果不写setAction()则只显示左侧提示内容.下图演示右滑Snackbar取消和点击Action弹出Toast提示 颜色修改 Action 文字颜色修改.setActionTextColor(color)即可 修改Snackbar背景颜色api中并不能直接修改背景颜色,通过查看源码Snackbar加载了R.layout.design_layout_snackbar_include布局文件 12345678910111213141516171819202122232425262728293031&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;TextView android:id=&quot;@+id/snackbar_text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:paddingTop=&quot;14dp&quot; android:paddingBottom=&quot;14dp&quot; android:paddingLeft=&quot;12dp&quot; android:paddingRight=&quot;12dp&quot; android:textAppearance=&quot;@style/TextAppearance.Design.Snackbar.Message&quot; android:maxLines=&quot;2&quot; android:layout_gravity=&quot;center_vertical|left|start&quot; android:ellipsize=&quot;end&quot; android:textAlignment=&quot;viewStart&quot;/&gt;&lt;Button android:id=&quot;@+id/snackbar_action&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;0dp&quot; android:layout_marginStart=&quot;0dp&quot; android:layout_gravity=&quot;center_vertical|right|end&quot; android:paddingTop=&quot;14dp&quot; android:paddingBottom=&quot;14dp&quot; android:paddingLeft=&quot;12dp&quot; android:paddingRight=&quot;12dp&quot; android:visibility=&quot;gone&quot; android:textColor=&quot;?attr/colorAccent&quot; style=&quot;?attr/borderlessButtonStyle&quot;/&gt;&lt;/merge&gt; TextView:Snackbar左侧的message,Button是右侧的Action修改Snackbar背景颜色和message字体颜色就是这样:1234567public static void setSnackbarColor(Snackbar snackbar, int messageColor, int backgroundColor) &#123; View view = snackbar.getView();//获取Snackbar的view if(view!=null)&#123; view.setBackgroundColor(backgroundColor);//修改view的背景色 ((TextView) view.findViewById(R.id.snackbar_text)).setTextColor(messageColor);//获取Snackbar的message控件，修改字体颜色 &#125;&#125; 简单修改代码就能改变背景颜色,message字体颜色123456789101112131415final Snackbar make = Snackbar.make(coordinatorLayout, &quot;hello world&quot;, Snackbar.LENGTH_INDEFINITE);setSnackbarColor(make,getResources().getColor(R.color.black),getResources().getColor(R.color.colorAccent));make.setActionTextColor(getResources().getColor(R.color.blue));tv.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; make.setAction(&quot;你好&quot;, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(SnackbarActivity.this,&quot;Snackbar Action被点击了&quot;,Toast.LENGTH_LONG).show(); &#125; &#125;) .show(); &#125;&#125;); 效果图:背景变成了红色,Message字体颜色为黑色,Action字体颜色蓝色 总结Snackbar使用和Toast很是相似,出现在所有屏幕其他元素之上,make()生成Snackbar,show()显示.可以设置action设置右侧按钮,增加交互Snackbar样式修改,可直接通过setActionTextColor()修改action按钮颜色,要想修改背景和message颜色,就需要snackbar.getView()修改背景颜色,findviewbyid修改snackbar_text颜色最后推荐Snackbar和CoordinatioLayout配合使用,以达到和其他组件(比如FloatingActionButton)交互效果,后面会讲到CoorinationLayout 参考:http://www.jianshu.com/p/cd1e80e64311/]]></content>
      <tags>
        <tag>material design组件学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toolbar]]></title>
    <url>%2F2017%2F11%2F06%2FToolbar%2F</url>
    <content type="text"><![CDATA[Toolbar简介ToolBar是Android 5.0推出的一个新的导航控件用于取代之前的ActionBar，由于其高度的可定制性、灵活性、具有Material Design风格等优点，越来越多的应用也用上了ToolBar，比如常用的知乎软件其顶部导航栏正是使用ToolBar。官方考虑到仍有一部分用户的手机版本号低于5.0，所以，ToolBar也放进了support v7包内，使得低版本的系统也能使用上ToolBar。本文将使用support v7支持包的ToolBar来进行讲解，包括其基本用法、样式定制等知识点。 引入support v7支持包1implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; 更改主题需要使用此支持包内主题Theme.AppCompat12&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;/style&gt; xml布局文件1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/tbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;tv标题&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt;&lt;/RelativeLayout&gt; 效果图:Toolbar正常显示,没有设置背景色所以看不到具体高度.继续 属性设置背景颜色可以直接添加background,但是为了统一,使用?attr/colorPrimary. Toolbar中添加1android:background=&quot;?attr/colorPrimary&quot; title,subtitle,logo,navigation…123456Toolbar toolbar = findViewById(R.id.tbar);toolbar.setLogo(R.mipmap.ic_launcher);toolbar.setTitle(&quot;Title&quot;);toolbar.setSubtitle(&quot;Subtitle&quot;);setSupportActionBar(toolbar);//把toolbar作为操作栏,必不可少toolbar.setNavigationIcon(R.mipmap.nav); 效果图:如果你想修改标题和子标题的字体大小、颜色等，可以调用 setTitleTextColor 、 setTitleTextAppearance 、 setSubtitleTextColor 、 setSubtitleTextAppearance 这些API。 这些属性也可在.xml文件中设置12345&lt;android.support.v7.widget.Toolbar ... app:logo=&quot;@mipmap/ic_launcher&quot; app:subtitle=&quot;subtitle&quot; app:title=&quot;Title&quot;&gt; 添加菜单选项新建res/menu/menu_toolbar.xml123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/share&quot; android:title=&quot;分析&quot; android:icon=&quot;@mipmap/share&quot; app:showAsAction=&quot;ifRoom&quot;/&gt; &lt;item android:id=&quot;@+id/search&quot; android:title=&quot;搜索&quot; android:icon=&quot;@mipmap/search&quot; app:showAsAction=&quot;ifRoom&quot;/&gt; &lt;item android:id=&quot;@+id/collection&quot; android:title=&quot;收藏&quot; android:icon=&quot;@mipmap/collection&quot; app:showAsAction=&quot;ifRoom&quot;/&gt; &lt;item android:id=&quot;@+id/setting&quot; android:title=&quot;设置&quot; app:showAsAction=&quot;never&quot;/&gt;&lt;/menu&gt; app:showAsAction=”ifRoom|never”;ifRoom:toolbar能放得下,就显示在toolbar,否则折叠到更多;never直接折叠到更多 Activity重新onCreateOptionMenu(),将此菜单加载进去12345@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu_toolbar,menu); return true;&#125; 效果图: 若没有出现menu,请检查是否有将toolbar作为操作栏:1setSupportActionBar(toolbar);//把toolbar作为操作栏,必不可少 添加点击事件1234567891011121314151617toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123; int itemId = item.getItemId(); String s = &quot;&quot;; switch (itemId)&#123; case R.id.share: s = &quot;share&quot;; break; case R.id.search: s = &quot;search&quot;; break; &#125; Toast.makeText(ToolBarActivity.this,s+&quot; 被点击&quot;,Toast.LENGTH_SHORT).show(); return true; &#125;&#125;); 样式修改(美化) 上图可以看出右边3个竖排圆点式黑色的,如果想修改为白色?主题中设置: android:textColorSecondary 1234&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; ... &lt;item name=&quot;android:textColorSecondary&quot;&gt;#ffffff&lt;/item&gt;&lt;/style&gt; popup menu背景颜色字体颜色修改 1234&lt;!-- toolbar弹出菜单样式 --&gt;&lt;style name=&quot;ToolbarPopupTheme&quot; parent=&quot;@style/ThemeOverlay.AppCompat.Dark&quot;&gt; &lt;item name=&quot;android:colorBackground&quot;&gt;#000000&lt;/item&gt;&lt;/style&gt; toolbar添加属性1toolbar:popupTheme=&quot;@style/toolbarpopuptheme&quot; 效果图如此就能改变menu弹出菜单的背景颜色,同时文字颜色也会自动调整 修改popup menu 弹出位置默认情况popup menu覆盖在toolbar上,如上图.想要其在toolbar下方修改styles.xml: 1234567&lt;style name=&quot;ToolbarPopupTheme&quot; parent=&quot;@style/ThemeOverlay.AppCompat.Dark&quot;&gt; &lt;item name=&quot;android:colorBackground&quot;&gt;#000000&lt;/item&gt; &lt;item name=&quot;actionOverflowMenuStyle&quot;&gt;@style/OverflowMenuStyle&lt;/item&gt; &lt;!--新增一个item，用于控制menu--&gt;&lt;/style&gt;&lt;style name=&quot;OverflowMenuStyle&quot; parent=&quot;Widget.AppCompat.Light.PopupMenu.Overflow&quot;&gt; &lt;item name=&quot;overlapAnchor&quot;&gt;false&lt;/item&gt; &lt;!--把该属性改为false即可使menu位置位于toolbar之下--&gt;&lt;/style&gt; 效果图: 总结Toolbar使用比较简单(设置title,logo…,popup menu),美化.做个小结 向下兼容用v7包(引入support v7包) 主题使用v7包的Theme.AppCompay 一系列的参数设置(title,logo…),可以在代码中写,也可以做xml文件中写 添加菜单项:新建menu文件,Activity重写onCreateOptionMenu方法,并在此方法中加载menu menu点击事件setOnMenuItemClickListener() 样式修改(美化):更多选项图标颜色修改;popup menu背景颜色修改;弹出框弹出位置修改.]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>material design组件学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DrawerLayout]]></title>
    <url>%2F2017%2F11%2F03%2FDrawerLayout%2F</url>
    <content type="text"><![CDATA[DrawerLayout:抽屉布局;DrawerLayout + NavigationView 效果绝佳.使用DrawerLayout需要导入Design包1compile &apos;com.android.support:design:26.1.0&apos; .xml123456789101112131415161718192021222324252627&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/dl&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingTop=&quot;@dimen/tool_bar_top_padding&quot; android:background=&quot;#33ff0000&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;content&quot; android:textSize=&quot;24sp&quot;/&gt; &lt;/RelativeLayout&gt; &lt;android.support.design.widget.NavigationView android:id=&quot;@+id/nav&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; app:menu=&quot;@menu/draw_menu&quot; app:headerLayout=&quot;@layout/nav_headerlayout&quot;&gt; &lt;/android.support.design.widget.NavigationView&gt; 最外层是DrawerLayout,包含2部分内容:主内容一定要是DrawerLayout的第一个子视图,并且宽高都是math_parent[上例RelativeLayout为主内容];NavigationView为抽屉. 关键:此属性android:layout_gravity=”start”定义抽屉从左滑出,或”end”从右滑出,不推荐使用left和right.NavigationView:为导航菜单,后面会具体讲解. 监听事件DrawerLayout.DrawerLayoutListener作为监听器12345678910111213141516drawerLayout.addDrawerListener(new MyDrawerListener());private class MyDrawerListener implements DrawerLayout.DrawerListener&#123; public void onDrawerSlide(View drawerView, float slideOffset) &#123; //当抽屉被滑动时调用 滑动幅度0-1 &#125; public void onDrawerOpened(View drawerView) &#123; //抽屉完全被打开 &#125; public void onDrawerClosed(View drawerView) &#123; //抽屉完全被关闭 &#125; public void onDrawerStateChanged(int newState) &#123; //当抽屉状态改变时候被调用 //状态是state:0(闲置);1(拖拽);2(固定) &#125; &#125; 或设置DrawerListener的子类SimpleDrawerListener，使用这个类的时候不必实现全部的回调函数，可以根据自己的需要重写相应的方法。 NavigationView上例xml中的NavigationView可以换成别的来定义侧滑菜单部分,但是需要花费时间.使用NavigationView简单,统一.NavigationView分为两部分,上面一部分叫做HeaderLayout,下面的是Menu NavigationView属性上例NavigationView部分1234567&lt;android.support.design.widget.NavigationView android:id=&quot;@+id/nav&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; app:menu=&quot;@menu/draw_menu&quot; app:headerLayout=&quot;@layout/nav_headerlayout&quot;&gt; 属性解释: android:layout_gravity=”start”:表示该view从左侧滑出(end:右侧),必须指定. app:headerLayout=”@layout/nav_headerlayout”:引用一个头部布局,就是图1上面的蓝色背景部分,包含背景和用户名welau. app:menu=”@menu/draw_menu”:引用一个menu作为下面的点击项.HeaderLayout布局nav_headerlayout.xml:123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#4400ffff&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_headerlayout&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginTop=&quot;@dimen/tool_bar_top_padding&quot; android:text=&quot;welau&quot; android:textSize=&quot;24sp&quot; /&gt;&lt;/RelativeLayout&gt; Menu文件draw_menu.xml12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/item1&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;定制&quot;/&gt; &lt;item android:id=&quot;@+id/item2&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;我的&quot;/&gt; &lt;item android:id=&quot;@+id/item3&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;设置&quot;/&gt; &lt;item android:id=&quot;@+id/item4&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;关于&quot;/&gt;&lt;/menu&gt; 看看效果问题:图片都变成了灰色!!! NavigationView布局中添加app:itemIconTint=”#f00”,那么图标就变成了红色!!! 使用原图显示,在java代码中设置:1navigationView.setItemIconTintList(null); 还有2个常用属性: app:itemBackground=”@color/colorAccent”设置item的背景颜色 app:itemTextColor=””设置item的文字颜色 Menu属性menu item间添加分割线:使用group,并给该group设置id(必须设置,不然无效)1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;group android:id=&quot;@+id/g1&quot;&gt; &lt;item android:id=&quot;@+id/item1&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;定制&quot; /&gt; &lt;/group&gt; &lt;item android:id=&quot;@+id/item2&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;我的&quot; /&gt; &lt;item android:id=&quot;@+id/item3&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;设置&quot; /&gt; &lt;group android:id=&quot;@+id/g2&quot;&gt; &lt;item android:id=&quot;@+id/item4&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;关于&quot; /&gt; &lt;/group&gt;&lt;/menu&gt; 效果图: 事件处理头部点击事件获取头部控件HeaderLayout:例子中的nav_headerlayout.layout12//获取头布局文件 View headerView = navigationView.getHeaderView(0); 通过headerView.findViewById()获取HeaderLayout中的view123View headerView = navigationView.getHeaderView(0); TextView tv_name = headerView.findViewById(R.id.tv_name); tv_name.setText(&quot;header&quot;); 效果图: Menu item点击事件navigationView.setNavigationItemSelectedListener(NavigationItemSelectedListener)123456789101112131415161718navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; int itemId = item.getItemId(); switch (itemId) &#123; case R.id.item1: Toast.makeText(DrawerLayoutActivity.this,&quot;item1被点击&quot;,Toast.LENGTH_LONG).show(); break; case R.id.item2: break; case R.id.item3: break; case R.id.item4: break; &#125; return true; &#125; &#125;); 效果图: 总结 DrawerLayout:抽屉布局,第一个Layout为主内容区域,侧滑菜单必须指定android:layout_gravity=”start|end”; DrawerLayout事件:drawerLayout.addDrawerListener(DrawerListener) 侧滑菜单可是自己写也可以使用NavigationView; NavigationView中app:headerLayout引入头部布局,常见app显示图片加文字; app:menu引入item; NavigationView 通过getHeaderView获取引入的头部布局; NavigationView menu item的点击事件:setNavigationItemSelectedListener()]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>material design组件学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TextInputLayout]]></title>
    <url>%2F2017%2F11%2F03%2FTextInputLayout%2F</url>
    <content type="text"><![CDATA[TextInputLayout是用来增强Edittext[TextInputEditText]，使用的时候包裹Edittext。当edittext获取焦点是，edittext的hint值就会浮到edittext的上方;setError(str)下方出现提示 添加依赖TextInputLayout是在Material Design中的,如果我们要使用的话,必须在gradle文件中配置 1234dependencies &#123; compile &apos;com.android.support:appcompat-v7:25.0.1&apos; compile &apos;com.android.support:design:25.0.1&apos;&#125; 使用 （xml）1234567891011121314&lt;android.support.design.widget.TextInputLayout android:id=&quot;@+id/til_1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;&gt; &lt;EditText android:id=&quot;@+id/et_1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;name&quot; /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; 使用TextInputLayout包裹一个（只能是一个）EdiTtext。hint可以在TextInputLayout或EditText中设置。 属性说明浮动标签（hintEnable）若想关闭浮动标签（默认开启）：1app:hintEnable=&quot;false&quot; 浮动标签过渡动画浮动标签显示与隐藏之间有一个过渡动画(默认是开启的),可以通过以下方法设置1app:hintAnimationEnabled=&quot;false&quot; 计数器（counterEnable）如果我们想要在账号那栏后面加个字数统计,例如当我们的账号是固定位数时(例如手机号码,),我们可以让用户看到自己当前输入的长度,我们只需要在TextInputLayout加入1app:counterEnabled=&quot;true&quot; 设置最大长度1app:counterMaxLength=&quot;11&quot; 此属性并不能限制用户输入，而是用另一种颜色提示用户输入长度超过了设置长度 setError() 错误提示TextInputLayout提供了错误提示的方法，出现在EditText下方；setError（null）取消错误提示 密码可见按钮1app:passwordToggleEnabled=&quot;true&quot; //默认是关闭的 需要在子EditText中加入属性android:inpuTtype=”textPassword” 自定义密码可见按钮图标1app:passwordToggleDrawable=&quot;@mipmap/ic_launcher&quot; 密码可见按钮上色1app:passwordToggleTint=&quot;@color/colorAccent&quot; 密码可见按钮设置模式12//screen,src_in,src_atop,src_over,multiply等几种设计模式app:passwordToggleTintMode=&quot;screen&quot; //screen 自定义浮动标签1app:hintTextAppearance=&quot;@style/hintAppearance&quot; 1234&lt;style name=&quot;hintAppearance&quot; parent=&quot;TextAppearance.AppCompat&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;14sp&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;#ffee00&lt;/item&gt;&lt;/style&gt; 自定义错误提示样式1app:errorTextAppearance=&quot;@style/errorAppearance&quot; 1234&lt;style name=&quot;errorAppearance&quot; parent=&quot;TextAppearance.AppCompat&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;14sp&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;@color/red&lt;/item&gt;&lt;/style&gt; 补充（EditText 和 TextInputEditText区别）继承关系：123456java.lang.Object ↳ android.view.View ↳ android.widget.TextView ↳ android.widget.EditText ↳ android.support.v7.widget.AppCompatEditText ↳ android.support.design.widget.TextInputEditText TextInputEditText作为EditText的子类，为TextInputLayout设计的一个子容器。输入法在’extract’模式的时候，使用TextInputEditText类允许显示提示，而EditText则没有。上图，用户名使用的事EditText。密码使用的是TextInputEditText,可以看到输入的时候都变成了全屏模式，用户名使用EidtText的时候hint就隐藏了，而密码使用TextInputEditText的时候hint可以正常显示。由此可见TextInputEditText的设计就是修复了这个缺陷，所以TextInputLayout和TextInputEditText配合使用的效果最好! 总结TextInputLayout包裹EditText，帮助EditText做些事情：1.hint提到EditText头上去；2.错误提示放在下发；EditTEXT原本也有错误提示，在输入框右边；3.密码小眼睛（app:passwordToggleEnabled=”true”）。4.TextInputLayout应和TextInputEditText配合使用，不推荐配合EditText使用。 参考:http://blog.csdn.net/johnny901114/article/details/51918436http://www.jianshu.com/p/a9b48dee86e0]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>material design组件学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout-进阶的RelativeLayout]]></title>
    <url>%2F2017%2F11%2F02%2FConstraintLayout-%E8%BF%9B%E9%98%B6%E7%9A%84RelativeLayout%2F</url>
    <content type="text"><![CDATA[伴随着Android Studio 2.2的正式推送,最大的亮点是布局的蓝图模式以及与之配套的ConstraintLayout关注度一下子高了起来. ConstraintLayout,翻译过来,可以叫约束布局,其子view就是通过一个个属性的约束,来决定自己的位置,大小,而传统的RelativeLayout也类似,所以可以看成是RelativeLayout的一种进化版版本,属性布局用法相对RelativeLayout来说较为复杂,但是当你熟悉之后你会爱上它的. 众所周知,Android APP的布局复杂度会极大的影响程序的流畅度,传统的ViewGroup用的最多的就是RelativeLayout与LineaLayout. 一般能用RelativeLayout替换LineaLayout就替换,因为LinearLayout虽然简单,但是会加深层级. 而有时候却不得不使用LinearLayout,在于LinearLayout有一个layout_weight属性,可以设置LinearLayout的ChildView按照一定的比例布局,这是RelativeLayout做不到的. ConstraintLayout的其他的属性和用法基本与RelativeLayout一致,如果对RelativeLayout比较熟悉的童鞋很容易上手,而ConstraintLayout最大的优点便是可以添加比例的控制. 概念ConstraintLayout约束布局的含义: 根据布局中的其他元素或视图, 确定View在屏幕中的位置, 受到三类约束, 即其他视图, 父容器(parent), 基准线(Guideline).1layout_constraint[本源位置]_[目标位置]=&quot;[目标ID]&quot; 例如：1app:layout_constraintBottom_toBottomOf=&quot;@+id/constraintLayout&quot; 约束当前View的底部至目标View的底部, 目标View是constraintLayout. 即, 把当前View的底部对齐到constraintLayout的底部. 基本约束属性ConstraintLayout是RelativeLayout的进化版,如果RelativeLayout的子view没有设置任何基本属性,则置于左上角,ConstraintLayout同理. ConstraintLayout基本属性的值可以是某个控件的id,也可以是”parent”,简单的概括就是top,bottom,left,right,baseline. 约束属性值为id时对照表 约束属性值等于parent当基本属性值为parent时,必须成对出现才有意义,即top与bottom,left与right,start与end成对. 比例属性闪亮登场12layout_constraintHorizontal_bias=&quot;0.4&quot;layout_constraintVertical_bias=&quot;0.6&quot; 这两个属性接受浮点型,是一个比例,数值在0-1之间,如不写这属性,默认为0.5 点击左下角切换的Design,再点击Button选中这个控件,右边栏会出现约束属性图 属性理解： 箭头向里 表示控件的宽度/高度是适应内容的,弹簧状（“工”字形） 表示控件是宽度/高度是具体数值 上下两个0表示控件的上下margin是0dp 小球50这个数值表示在垂直方向上,上下的比例是0.5:0.5鼠标拖动小球,上下移动会发现数值,控件垂直方向上的位置都跟着改变.拖动到20,切换到代码,会发现代码新增了一个属性,此时控件的上下比例是:0.21app:layout_constraintVertical_bias=&quot;0.2&quot; 控件大小比例属性1app:layout_constraintDimensionRatio=&quot;1:2&quot; 子view控制自身的宽高比（宽高1:2）**注意： 这个属性生效需要以下条件：left，right，top，bottom 四条边中至少一个约束 宽高有且只有一个是0dp** Guideline导航线123app:layout_constraintGuide_begin=&quot;50dp&quot;app:layout_constraintGuide_end=&quot;50dp&quot;app:layout_constraintGuide_percent=&quot;50&quot; 介绍导航线之前,先想一下,根据上面对ConstraintLayout的介绍,要你布置一个菜单控件,菜单栏每一项均分屏幕宽度,按照以前使用LinearLayout,会把每一个子view的weight设置为1,则均分了屏幕宽度12345&lt;LinearLayout&gt; &lt;View/&gt; &lt;View/&gt; &lt;View/&gt;&lt;/LinearLayout&gt; 而使用ConstraintLayout则会发现前面介绍的比例,是相对parent来说的,如果要均分屏幕宽度,必须借助透明的分割线来布局1234567&lt;ConstraintLayout&gt; &lt;View,右边约束分割线1/&gt; &lt;分割线1,距离左边33%/&gt; &lt;View,左边约束分割线1,右边约束分割线2/&gt; &lt;分割线2,距离左边66%/&gt; &lt;View,左边约束分割线2/&gt;&lt;/ConstraintLayout&gt; 而这个分割线其实谷歌已经帮我们写好了,就是Guideline.蓝图介绍中,6对应的就是添加导航线.切换到蓝图模式,点击6,就可以添加一个水平/垂直的导航线 添加垂直导航线 Guideline属性对照表 Guideline属性值 Guideline本身对于用户来说是不可见的,所以其宽高的值没有任何意义,也不起作用.1234567&lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline&quot; android:layout_width=&quot;wrap_content&quot;//无意义 android:layout_height=&quot;10dp&quot;//无意义 android:orientation=&quot;vertical&quot;//决定这是一条水平导航线还是垂直导航线 app:layout_constraintGuide_percent=&quot;0.333&quot;//决定导航线的位置/&gt; 此时再添加一条比例为0.666的导航线,即可三等分屏幕 总结有了GuideLine就可以抛弃LinearLayout。单单使用ConstraintLayout写布局，减少布局层级。 参考：http://www.jianshu.com/p/d64d845b6b90]]></content>
  </entry>
  <entry>
    <title><![CDATA[android material design组件学习]]></title>
    <url>%2F2017%2F11%2F02%2Fandroid-material-design%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[TextInputLayoutToolbarDrawerLayoutSnackbarFloatingActionButtonTabLayout]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>material design组件学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android material design]]></title>
    <url>%2F2017%2F11%2F02%2Fandroid-material-design%2F</url>
    <content type="text"><![CDATA[核心思想material design的核心思想，就是把物理世界的体验带进屏幕。去掉现实中的杂质和随机性，保留其最原始纯净的形态、空间关系、变化与过渡，配合虚拟世界的灵活特性，还原最贴近真实的体验，达到简洁与直观的效果。 参考：http://www.uisdc.com/comprehensive-material-design-note]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[标签（tags）使用]]></title>
    <url>%2F2017%2F10%2F31%2F%E6%A0%87%E7%AD%BE%EF%BC%88tags%EF%BC%89%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[标签（tags）使用教程 1.新建页面，命名为tags；1hexo new page &quot;tags&quot; 2.编辑刚新建的页面（source/tags/index.md），将页面的类型设置为tags，主题将自动为这个页面显示标签云；123title: tagsdate: 2017-10-31 12:26:42type: &quot;tags&quot;//这里 *注意：如果有启用多说或Disqus评论，默认页面也会带有评论。需要关闭的话，请添加字段comments并将其值设置为false，如：1234title: tagsdate: 2017-10-31 12:26:42type: &quot;tags&quot;comments: false//这里 3.在菜单中添加链接。编辑主题配置文件，添加tags到menu中；12345menu: 首页: / || home 标签: /tags/ || tags //这里 归档: /archives/ || archive 关于: /about/ || user]]></content>
      <tags>
        <tag>hexo 教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 引用图片]]></title>
    <url>%2F2017%2F10%2F30%2Fhexo-%E5%BC%95%E7%94%A8%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[hexo可通过插件引用图片 hexo-asset-image.新建文章：1hexo new &quot;hexo-引用图片&quot; 在source/_posts目录下会生成“hexo-引用图片”文件夹和“hexo-引用图片.md”文件，文件夹中存放图片（test.jpg）。 安装1npm install hexo-asset-image --save 引用1![描述信息](hexo-引用图片/test.jpg)]]></content>
      <tags>
        <tag>hexo 教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next添加algolia搜索]]></title>
    <url>%2F2017%2F10%2F30%2Fhexo-next%E6%B7%BB%E5%8A%A0algolia%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[当博客达到一定数量的时候，为了方便找到想找的内容，就需要用到搜索了。 效果图 开始添加 下载最新的next主题（5.1.0），因为最新版的已经集成了algolia搜索，可以省去很多配置和修改。 去algolia官网注册账号（可直接使用github账号登录） 新建index 打开API Keys页面，里面的信息等会需要写到hexo的配置文件中 在根目录的站点配置文件_config.yml中加入如下配置，参照上图申请到的key值 1234567891011algolia: appId: &apos;appid&apos; apiKey: &apos;apiKey&apos; adminApiKey: &apos;adminApiKey&apos; indexName: &apos;上面填写的index名&apos; chunkSize: 5000 fields: - title - slug - path - content:strip 执行hexo algolia. 查看algolia -&gt; Indices如果无法提交成功，先执行hexo clean即可。 在\themes\next下找到_config.yml，找到如下内容，将enable修改为true，labels修改为自己需要的 123456789# Algolia Searchalgolia_search: enable: true hits: per_page: 10 labels: input_placeholder: &quot;输入关键字&quot; hits_empty: &quot;没有找到与「$&#123;query&#125;」相关的内容&quot; hits_stats: &quot;$&#123;hits&#125;条相关记录，共耗时 $&#123;time&#125; ms&quot; 在themes\next\layout_partials中找到header.swig，找到以下代码并修改 123456789algolia: &#123; &lt;!-- applicationID: &apos;&#123;&#123; theme.algolia.applicationID &#125;&#125;&apos;,--&gt; &lt;!-- 改为 (对应站点配置_config.yml中的algolia.appId)--&gt; applicationID: &apos;&#123;&#123; theme.algolia.applicationID &#125;&#125;&apos;, apiKey: &apos;&#123;&#123; theme.algolia.apiKey &#125;&#125;&apos;, indexName: &apos;&#123;&#123; theme.algolia.indexName &#125;&#125;&apos;, hits: &#123;&#123; theme.algolia_search.hits | json_encode &#125;&#125;, labels: &#123;&#123; theme.algolia_search.labels | json_encode &#125;&#125;&#125; algolia刷新添加了新文章，搜索不到时需要刷新algolia1hexo algolia 如果失败，clean一下1hexo clean 然后再执行 hexo algolia]]></content>
      <tags>
        <tag>hexo 教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令]]></title>
    <url>%2F2017%2F10%2F30%2Fhexo%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[本文介绍hexo的常用命令。 hexonpm install hexo -g #安装npm update hexo -g #升级npm init #初始化 服务器hexo s #启动服务预览并自动更新，无需重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义IPhexo clean #清理缓存hexo g #生成静态网页hexo d #开始部署 hexo g -d #生成静态网页并部署，两步并一步 草稿hexo publish [layout] 模版hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo server #启动服务预览hexo generate #生成静态页面hexo deploy #部署 简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 设置文章摘要 报错error:ERROR Deployer not found: git解决方法npm install hexo-deployer-git –save]]></content>
      <tags>
        <tag>hexo 教程</tag>
      </tags>
  </entry>
</search>
